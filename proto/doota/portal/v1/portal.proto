syntax = "proto3";

package doota.portal.v1;

option go_package = "github.com/shank318/doota/pb/doota/portal/v1;pbportal";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "doota/core/v1/core.proto";

service PortalService {
  rpc GetConfig(.google.protobuf.Empty) returns (Config);
  rpc Self(.google.protobuf.Empty) returns (User);
//  rpc AddUser(AddUserRequest) returns (User);
//  rpc RenewUser(RenewUserRequest) returns (.google.protobuf.Empty);
  rpc GetIntegration(GetIntegrationRequest) returns (Integration);
  rpc Batch(BatchReq) returns (BatchResp);
  rpc CreateCustomerCase(CreateCustomerCaseReq) returns (.google.protobuf.Empty);
  rpc PasswordlessStart(PasswordlessStartRequest) returns (.google.protobuf.Empty);
  rpc PasswordlessVerify(PasswordlessStartVerify) returns (JWT);
  rpc OauthAuthorize(OauthAuthorizeRequest) returns (OauthAuthorizeResponse);
  rpc OauthCallback(OauthCallbackRequest) returns (OauthCallbackResponse);
  rpc SocialLoginCallback(OauthCallbackRequest) returns (JWT);
  rpc GetIntegrations(.google.protobuf.Empty) returns (Integrations);

  // Reddit
  rpc CreateKeywords(CreateKeywordReq) returns (CreateKeywordsRes);
  rpc AddSource(AddSourceRequest) returns (core.v1.Source);
  rpc GetSources(.google.protobuf.Empty) returns (GetSourceResponse);
  rpc RemoveSource(RemoveSourceRequest) returns (.google.protobuf.Empty);
  rpc GetRelevantLeads(GetRelevantLeadsRequest) returns (GetLeadsResponse);
  rpc GetLeadsByStatus(GetLeadsByStatusRequest) returns (GetLeadsResponse);
  rpc UpdateLeadStatus(UpdateLeadStatusRequest) returns (.google.protobuf.Empty);
  rpc CreateOrEditProject(CreateProjectRequest) returns (doota.core.v1.Project);
}

message CreateKeywordsRes {
  repeated core.v1.Keyword keywords = 1;
}

message CreateProjectRequest {
  string id = 1;
  string name = 2;
  string description = 3;
  string website = 4;
  string target_persona = 5;
}

message UpdateLeadStatusRequest {
  doota.core.v1.LeadStatus status = 1;
  string lead_id = 2;
}

message GetLeadsByStatusRequest {
  doota.core.v1.LeadStatus status = 1;
  int32 page_no = 3;
  DateRangeFilter date_range = 4;
}

enum DateRangeFilter {
  DATE_RANGE_UNSPECIFIED = 0;
  DATE_RANGE_TODAY = 1;
  DATE_RANGE_YESTERDAY = 2;
  DATE_RANGE_7_DAYS = 3;
}

message GetRelevantLeadsRequest {
  optional string sub_reddit = 1;
  float relevancy_score = 2;
  int32 page_no = 3;
  DateRangeFilter date_range = 4;
}

message GetLeadsResponse {
  repeated doota.core.v1.Lead leads = 1;
  LeadAnalysis analysis = 2;
}

message LeadAnalysis {
  uint32 posts_tracked = 1;
  uint32 relevant_posts_found = 2;
  uint32 comment_sent = 3;
  uint32 comment_scheduled = 4;
  uint32 dm_sent = 5;
  uint32 dm_scheduled = 6;
}

message AddSourceRequest {
  string name = 1; // eg. r/SAAS
}

message GetSourceResponse {
  repeated doota.core.v1.Source sources = 1;
}

message RemoveSourceRequest {
  string id = 1;
}

message CreateCustomerCaseReq {
  string first_name = 1;
  string last_name = 2;
  string phone = 3;
  string organization_id = 4;
  string due_date = 5;
  string prompt_type = 6;
}

message CreateKeywordReq {
  repeated string keywords =1;
}

message BatchReq {
  bytes csv_data = 1;
  string organization_id = 2;
}

message BatchResp {
  int32 rows = 1;
  int32 rows_extracted = 2;
  repeated string rejected_rows = 3;
}

message Config {
  string auth0_domain = 1;
  string auth0_client_id = 2;
  string auth0_scope = 3;
  string msoft_auth0_callback_url = 4;
  string full_story_org_id = 5;
  string google_auth0_callback_url = 6;
}

message PasswordlessStartRequest {
  string redirect_uri = 1;
  string email = 2;
}

message PasswordlessStartVerify {
  string email = 1;
  string code = 2;
}

message AuthStateRequest { string redirect_uri = 1; }

message State {
  string state = 1;
  string nonce = 2;
}

message User {
  string id = 1;
  string email = 2;
  bool email_verified = 3;
  UserRole role = 4;
  repeated Organization organizations = 7;
  .google.protobuf.Timestamp created_at = 10;
  repeated doota.core.v1.Project projects = 11;
  bool is_onboarding_done = 12;
}

message OauthAuthorizeRequest {
  IntegrationType integration_type = 1;
  string redirect_url = 2;
}

enum OauthAuthorizeType {
  OAUTH_AUTHORIZE_TYPE_UNSPECIFIED = 0;
  OAUTH_AUTHORIZE_TYPE_INTEGRATION = 1;
}

message OauthAuthorizeResponse { string authorize_url = 1; }

enum UserRole {
  USER_ROLE_UNSPECIFIED = 0;
  USER_ROLE_USER = 1;
  USER_ROLE_ADMIN = 2;
  USER_ROLE_PLATFORM_ADMIN = 3;
}

message IssueRequest {
  string code = 1;
  string state = 2;
}

message JWT {
  string token = 1;
  int64 expires_at = 2;
}

message Organization {
  string id = 1;
  string name = 2;
  OrganizationFeatureFlags feature_flags = 3;
  .google.protobuf.Timestamp created_at = 4;
}

message OrganizationFeatureFlags {
  core.v1.Subscription subscription = 1;
}

message Integration {
  string id = 1;
  string organization_id = 2;
  IntegrationType type = 3;
  IntegrationState status = 4;
  oneof details {
    RedditIntegration reddit = 6;
  }
}

message RedditIntegration {
  string user_name = 1;
}

message Integrations {
  repeated Integration integrations = 1;
}

message GetIntegrationRequest { IntegrationType type = 1; }

enum IntegrationType {
  INTEGRATION_TYPE_UNSPECIFIED = 0;
  INTEGRATION_TYPE_MICROSOFT = 1;
  INTEGRATION_TYPE_GOOGLE = 2;
  INTEGRATION_TYPE_REDDIT = 3;
}

enum IntegrationState {
  INTEGRATION_STATE_UNSPECIFIED = 0;
  INTEGRATION_STATE_ACTIVE = 1;

  // This is a transient state not stored in the actual integration model. This will
  // be that case when for multiple reasons, the token we had for this integration is
  // revoked.
  INTEGRATION_STATE_AUTH_REVOKED = 2;
}

message AddUserRequest {
  string email = 1;
  optional MessageSourceOptions message_source = 2;
  IntegrationType integration_type = 3;
}

message RenewUserRequest { string message_source_id = 1; }

message MessageSourceOptions {
  string integration_id = 1;
  string integration_external_id = 2;
}

message OauthCallbackRequest {
  string state = 1;
  optional string external_code = 2;
}

message OauthCallbackResponse { string redirect_url = 1; }
